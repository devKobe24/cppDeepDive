# Cpp Deep Dive 🤿 - Overview

# 주요 용어
- 소스 프로그램 파일
- 헤더 파일
- 목적 파일
- 번역 단위
- 빌드
- 통합개발환경
- 주석
- 선행처리
- 함수
- 입출력 스트림
- 명칭공간

# C++ 언어의 개요

C++는 AT&T 벨 연구소의 비야네 스트롭스트룹(Bjarne Stroustrup)이 C 언어를 확장하여 만든 **"객체지향 프로그래밍 언어"** 입니다.
(저는 이런 역사적인 사실이 참 재미있더라구요!!)

따라서 C가 가지고 있는 모든 기능이 C++ 안에 포함되어 있으며, 이와 더불어 몇 가지 새로운 내용이 C++에 추가되었습니다.

가장 중요한 것은 C는 **"절차적 프로그래밍 언어"** 이지만, **"C++은 객체지향 프로그래밍"** 을 지원하기 위한 부분이 포함된 것입니다.

**"절차적 프로그래밍(procedural programming)"** 은 적절한 단위로 정의된 처리 절차를 **함수(또는 프로시저)** 로 표현합니다.

또한 함수가 처리해야 할 데이터를 적절히 표현할 수 있는 **"데이터 구조를 만들 수 있습니다."**

**"하나의 프로그램"** 은 **"여러 개의 함수"** 와 **"다양한 구조로 표현된 데이터"** 로 **"구성"** 되며, 이 **"함수"** 들이 **"적절한 순서로 실행되도록 작성됨"** 으로써 **"그 프로그램으로 하려는 일을 해냅니다."**

C는 절차적 프로그래밍에 필요한 고급 프로그래밍 언어의 구문을 갖추고 있으며, 컴퓨터의 하드웨어와 밀접하게 관련된 저급 프로그래밍 언어인 어셈블리어를 사용하지 않고도 작성할 수 있게 설계되었습니다.

C가 다양한 응용프로그램을 작성하는 데 활용될 뿐만 아니라 유닉스(UNIX)와 같은 운영체제를 구현하거나 임베디드 시스템을 만들 때 널리 사용되는 이유는 이러한 언어의 특성에 기인합니다.

C++는 C를 기반으로 개발된 언어이므로 몇 가지 예외를 제외하고는 C의 문법을 그대로 따릅니다.

그러므로 C처럼 범용 프로그래밍 언어로서 다양한 응용프로그램을 개발하는 데 활용될 수 있고, 시스템 프로그래밍을 위한 언어로도 활용할 수 있습니다.

프로그래밍 방식 측면에서도 C++를 이용하여 C와 같이 절차적 프로그래밍 방식으로 프로그램을 만들 수도 있습니다.

그렇지만 C++는 C에서 지원하지 않는 프로그래밍 패러다임을 지원할 수 있도록 확장되었습니다.

C++는 클래스와 클래스 계층구조를 활용하는 **"객체지향 프로그래밍(object oriented programming)"** 을 할 수 있으며,
템플릿을 이용하여 **"일반화 프로그래밍(generic programming)"** 을 지원할 수 있습니다.

C++의 이러한 특성은 주어진 문제에 맞는 다양한 형식의 프로그램을 작성할 수 있는 유연성을 부여합니다.

# C++의 표준

국제표준화기구(International Organazation for Standardiza-tion, ISO)는 1989년부터 C++에 대한 표준화 작업에 착수하였습니다.

1998년에 승인된 첫 번째 표준은 ISO/IEC 14882:1998이며 공식 명칭은 "Information Technology-Programming Languages - C++"로, C++98이라는 비공식 명칭으로 부르기도 합니다.

이후 2003년에 C++98의 사소한 오류를 바로잡아 C++03을 발표했는데, C++98과 C++03을 함께 첫 번째 C++ 표준이라고 부릅니다.

2007년에는 C++03 표준의 C++ 표준 라이브러리를 확장한 ISO/IEC TR 19768:2007(C++ Technical Report 1, TR1)을 제안하였습니다.

TR1에는 **"정규표현식(regular expression), 스마트 포인터(smart pointers), 해시테이블(hash tables), 난수발생기(random number generators)"** 등이 포함되는데, 이들은 명칭공간 **"std::tr1"** 에 정의되었습니다.

2011년애는 두 번째 C++ 표준인 ISO/IEC 14882:2011(흔히 C++11이라고 부름)이 승인되었습니다.

TR1에 제안된 내용은 std **"명칭공간"** 으로 모두 옮겨 놓았으며, 언어와 라이브러리 모두에서 상당한 개선이 이루어졌습니다.

일부는 기존의 문제점을 개선한 것이지만, 이전 버전과는 다른 용법으로 사용되게끔 변경된 것도 있습니다.

예를 들어 auto라는 키워드는 자료형 추론에 사용되게끔 변경되었습니다.

이 외에도 문장 구조의 개선이나 추가, 실행이나 빌드의 성능 개선이 C++11에서 이루어졌습니다.

기본적인 언어의 틀은 그대로이지만, 이러한 과정을 통해 C++ 언어는 계속하여 발전해 왔습니다.

이러한 C++ 표준의 개정 작업은 지속적으로 진행되어, 2014년 8월에는 C++14, 2017년 12월에는 C++17이 발표되었습니다.

앞으로도 예정된 표준화 과정을 통해 새로운 경향에 맞게 진화해 갈 것입니다.

이처럼 C++ 언어에 대한 표준화가 이루어지고 있지만, 현실적으로 모든 컴파일러가 최신의 표준을 완전히 구현하는 것은 아닙니다.

따라서 C++ 언어의 기본적인 구문은 대부분의 컴파일러가 공통적으로 지원하지만, 최신 표준에서 도입된 컴파일러에 따라서는 번역하지 못하는 것도 있습니다.

# 소스 프로그램의 작성.

**"C++로 작성한 프로그램을 담고 있는 파일"** 을 **"소스(Source)파일"** 이라고 합니다.

**"C++ 프로그램의 소스 파일"** 에는 **"C++ 소스 프로그램 파일"** 과 **"C++ 헤더(header) 파일"** 이 있습니다.

C++ 소스 프로그램 파일은 C++의 프로그램 명령어들을 포함하는 프로그램이 작성된 파일로, 'cpp', 'cxx', 'C' 등 여러 가지 중 하나의 확장자를 갖는 이름으로 만듭니다.

간단한 프로그램이라면 하나의 소스 프로그램 파일에 프로그램을 완성할 수도 있습니다.

그러나 프로그램의 규모가 커지거나, 여러 프로그래머가 프로그램을 분담하여 작성할 경우에는 여러 개의 소스 프로그램 파일에 나누어 프로그램을 작성하게 됩니다.

이러한 경우에는 여러 소스 프로그램 파일에 공통적으로 들어가야 하는 부분이 발생하게 됩니다.

전역변수나 함수의 원형, 클래스 등의 선언문이 이러한 부분에 해당됩니다.

이렇게 공통적인 내용을 각각의 소스 프로그램 파일에 중복하여 작성하면 프로그램을 관리하기 어려워지며, 이로 인해 오류가 발생하기도 합니다.

**"헤더 파일"** 을 사용하면 이러한 어려움을 개선할 수 있습니다.

**"C++ 헤더 파일"** 은 이와 같은 **"공통부분을 별도로 작성한 것"** 으로, 보통 '.h'라는 확장자를 사용합니다.

헤더 파일은 단독으로 컴파일되지 않고, #include라는 **"선행처리기"** 지시어에 의해 소스 프로그램에 삽입되어 함께 컴파일됩니다.

이렇게 하면 여러 소스 프로그램 파일에 중복하여 선언하던 것이 하나의 헤더 파일에만 작성하면 되는 것으로 간소화되므로 편리합니다.

또한 우리가 직접 작성하지 않은 라이브러리를 사용하기 위해 선언해야 할 것들도 C++ 컴파일러에서 헤더 파일로 제공하고 있습니다.

하나의 소스 프로그램 파일과 그 파일에 삽입되는 헤더 파일들을 묶어 **"번역 단위(translation unit)"** 라고 합니다.

하나의 프로그램은 한 개 이상의 번역 단위로 구성됩니다.

## 🙋‍♂️ 참고 - 선언과 정의

**"선언(declaration)"** 이란 컴파일러에게 프로그램 중에 사용할 이름과 그 형식을 알리는 것을 의미합니다.
만일 이러한 선언이 그 이름에 대한 실체가 만들어지게 할 경우 **"정의(definition)"** 라고 합니다.

```cpp
// 1
int i;

// 2
extern int j;

// 3
int g(int a);

// 4
int f(int x, int y)

// 5
{

// 6
return g(x) * y;

// 7
}
```

라인 1번 문장은 i가 int형 값을 저장하는 변수의 이름임을 **"선언함"** 과 동시에 이 변수들을 위한 **"저장공간을 할당"** 합니다.

그러므로 이 문장은 변수 i를 **"정의하는 문장"** 입니다.

반면 2번 라인은 j라는 이름이 int형 변수라는 것을 컴파일러가 알 수 있게 하는 **"선언문"** 입니다.

이 문장에 의해 j의 **"저장공간이 할당되는 것은 아니고"**, 실제 j의 정의는 이와 별도로 이루어져야 합니다.

3번 라인은 함수 g를 어떠한 형식으로 호출하고 결과를 반환받게 되는지를 알리는 함수 원형의 **"선언문"** 입니다.

반면 4~7라인은 함수 f를 **"정의하는 문장"** 으로서, 이에 따라 **"실제 명령어 코드가 메모리 영역에 존재"** 하게 됩니다.

하나의 번역 단위 내에서 하나의 이름에 대한 **"선언"** 은 **"정의"** 가 아니라면 여러 번 반복될 수 있습니다.

다만 선언되는 내용은 동일해야만 합니다.

반면 **"정의"** 는 단 한 번만 할 수 있습니다.

예를들어 다음과 같이 작성하는 것은 에러가 아닙니다.

```cpp
// 1
extern int j;

// 2
extern int k; // j의 재선언
```

반면 다음은 중복 정의가 되므로 안 됩니다.

```cpp
// 1
int j;

// 2
int j; // 에러 : j의 중복 정의

```

# 프로그램의 빌드 

아래 그림은 C++ 프로그램의 **"실행 프로그램 파일(실행 파일)"** 을 만드는 과정을 보여줍니다.

소스 파일에 담겨 있는 프로그램은 컴퓨터가 직접 실행할 수 있는 프로그램이 아니며, 이것을 컴퓨터가 이해할 수 있는 명령으로 번역해야 합니다.

이 과정을 **"컴파일(compile)"** 이라고 하는데, 이렇게 번역하는 작업을 하는 프로그램을 **"컴파일러(compiler)"** 라고 합니다.

컴파일러가 하나의 번역 단위를 컴파일한 결과 만들어지는 **"목적 코드(object code)"** 를 저장하는 파일을 **"목적 파일(object file)"** 이라고 합니다.

목적 파일은 번역 단위별로 하나씩 만들어집니다.

예를 들어 마이크로소프트의 Visual Studio를 개발 도구로 사용한다면 확장자가 '.obj'인 목적 파일이 만들어 집니다.

아래 그림에서 **`Sample.cpp`** 에 **`iostream`** 과 **`sub.h`** 라는 헤더 파일의 내용이 삽입되어 하나의 **"번역 단위"**, 그리고 **`Sub.cpp`** 에 역시 **`iostream`** 과 **`sub.h`** 라는 헤더 파일의 내용이 삽입되어 또 하나의 **"번역 단위"** 를 형성하며, 이들을 컴파일한 결과 **'Sample.obj'** 와 **'Sub.obj'** 라는 두 개의 **목적 파일** 이 생성됩니다.

<img src = "https://github.com/devKobe24/images/blob/main/cpp-1.png?raw=true"><br>

이와 같이 만들어진 **"목적 파일"** 들을 연결하여 **"실행 파일"** 을 만듭니다.

이때 라이브러리와 함께 연결하여 실행 파일을 생성합니다.

**"라이브러리(library)"** 는 프로그램을 작성할 때 사용할 수 있는 클래스나 값, 함수 등을 모아 놓은 것을 의미합니다.

C++에 기본적으로 제공되는 것 외에도 다양한 용도로 만들어진 것들이 사용되기도 하는데, 여러 가지 유용한 함수 등을 이용할 수 있도록 제공하여 프로그램을 편리하게 개발할 수 있게 합니다.

때로는 프로그래머가 개발 프로젝트에 필요한 라이브러리를 직접 만들기도 합니다.

목적 파일과 라이브러리를 연결하여 실행 파일을 만드는 것을 **"링크(link)"** 라고 하며, 이 작업을 하는 도구를 **"링커(linker)"** 라고 합니다.

실행 파일이 만들어지려면 컴파일과 링크가 모두 이루어져야 합니다.

이와 같이 컴파일과 링크를 통해 실행 파일을 만드는 과정을 합하여 프로젝트를 빌드(build) 한다고 합니다.

# 통합개발환경

프로그램을 작성하고 이를 빌드하여 실행 파일을 만드는 데는 여러 단계를 거치는데, 각 단계마다 필요한 도구가 다릅니다.

먼저 소스 프로그램을 작성하기 위해서는 텍스트 에디터가 필요합니다.

일반적인 텍스트 에디터의 기능 외에 예약어, 상수 등을 강조해서 표시해 주는 기능, 괄호의 짝을 알려주는 기능, 구조체나 클래스의 멤버를 알려주는 기능, 함수의 매개변수를 알려주는 기능 등 C++ 프로그램을 작성하는 데 도움이 되는 기능을 포함하고 있다면 더욱 편리합니다.

소스 프로그램을 컴파일하고 링크하기 위해서는 컴파일러와 링커가 필요합니다.

프로그램에 오류가 있을 때는 오류를 발견하고 수정하는 디버깅(debugging)을 도와주는 기능이 있어야 할 것입니다.

이와 같이 소프트웨어 개발에 사용되는 여러 가지 도구들을 모아 놓은 것을 통합개발환경(integrated development environment, IDE)이라고 합니다.

C++ 프로그램을 개발하는 데 활용할 수 있는 IDE는 다양합니다.

대표적인 IDE로는 마이크로소프트 비주얼 스튜디오(Visual Studio)나 볼랜드(Borland) C++ Builder, Dev C++, macOS에서 사용되는 Xcode 등이 있습니다.
