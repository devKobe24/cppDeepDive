#include <iostream>

using namespace std;

int main() {
  // 변수 선언시 그 값을 저장하기 위한 메모리를 대입하게 되고 그 위치를 내부적으로 추적할 수 있게 됩니다.
  // 이렇게 프로그램이 내부적으로 메모리를 대입한 공간이 "주소"라고 부르는 공간입니다.

  int val = 3;

	cout << &val << endl;
  // 주소 연산자(&)를 통해서 우리의 값을, 메모리 어느 곳에 저장했는지 확인할 수 있습니다.
	// 16진수 표기가 메모리를 나타내는 가장 일반적인 방법입니다.
	// 때문에 보통의 메모리 주소 출력은 16진수로 출력이 됩니다.

	// C++ : 객체지향 프로그래밍
	/*
	객체지향 프로그래밍의 가장 큰 특징중 하나는 "컴파일 시간이 아닌 실행 시간(run time)에 어떠한 결정을 내릴 수 있다."는 점 입니다.

	예를 들어 이야기 해보겠습니다.

	배열을 생성한다고 가정해봅시다.

	- 재래적 / 절차적 프로그래밍에서는 컴파일 시간에 "배열의 크기가 미리 결정"되어야 배열을 생성할 수 있습니다.
	반면에,
	- 객체지향 프로그래밍에서는 "배열의 크기를 실행 시간에 결정할 수 있습니다."
		- 다시 말해, "값이 변할 수 있는 변수"로 "배열의 크기를 결정할 수 있다"는 뜻으로도 해석할 수 있습니다.
	*/

/*
포인터의 요지

기존의 변수 선언 과정에서는 우리가 사용할 변수의 이름을 통해서 그 변수를 관리하였습니다.
- "이제는 저장할 데이터를 다루는 주소에 이름을 붙인다" 라고 이해하면 됩니다.
	- 포인터 : 사용할 주소에 이름을 붙인다.
		- 즉, 포인터의 이름이 주소를 나타냅니다.
			- 이것을 구현하기 위하여 c++에서는 "간접값 연산자", "간접 참조 연산자" 라고 불리는 ("*") 이 기호를 통해 나타낼 수 있습니다.
*/

// 포인터 변수의 선언

	int *q; // c style
	int* w; // c++ style
	int* e, r; // e는 포인터 변수, r는 int형 변수

// 포인터 예시
	int a = 6;
	int* b;
	b = &a;

	cout << "a의 값 " << a << endl;
	// 포인터로 선언된 변수의 값을 확인하고 싶을 경우에는 간접 참조 연산자 "*"을 사용하면 그 값을 알 수 있습니다.
	cout << "*b의 값" << *b << endl;

	cout << "a의 주소 " << &a << endl;
	// 포인터로 선언된 변수의 주소값을 확인하고 싶을 경우에는 아무런 기호 없이 변수의 이름을 사용하면 그 주소값을 알 수 있습니다.
	cout << "*b의 주소" << b << endl;

	*b = *b + 1;

	cout << "이제 a의 값은 " << a << endl;

	// 정수는 사칙연산이 가능한 "수" 입니다.
	// "포인터"는 "위치"를 나타냅니다.
	// 따라서 "포인터"끼리 연산을 하는 것은 아무런 의미가 없습니다.
	// 즉, 포인터에 어떠한 정수를 대입하는 것은 아무런 의미가 없습니다.
	// 다만 어떤 변수의 주소를 대입함으로써 그 포인터를 이용하여 그 주소의 값에 변화를 주어서 그 값을 수정하게 하는 것이 가능합니다.
	

  return 0;
}